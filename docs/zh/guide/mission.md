# domtify 的使命与设计理念

很多开发者会问：**既然有原生 DOM API，为什么还需要 domtify？**

如果你完全习惯并享受直接使用原生 JavaScript，那么当然可以继续使用它。但在实际开发中，我们往往会一遍又一遍地遇到同样的问题：
重复的选择器查询、零散的 DOM 操作、难以组合的工具函数，以及缺乏统一风格的代码组织方式。

这些问题最终都会把你引向同一个方向：
**你开始为原生 DOM 封装自己的工具函数。**

那么问题来了：
这些自定义函数该用什么样的 API 设计？
什么样的调用方式才能既直观，又易于维护？

## 熟悉的语法，现代的实现

domtify 选择了一种大多数开发者都非常熟悉的思路 —— jQuery 语法。
这种设计并不是为了复刻某个库，而是为了降低心智负担，不必因为又要接触一个新的库而增加学习成本和精力。让你把注意力放在“要做什么”，而不是“怎么写一堆底层代码”。

## 让我们再聊回 jQuery

jQuery 在 Web 开发历史中具有不可替代的地位。
它在浏览器高度碎片化的年代，成功统一了 DOM 操作、事件模型和 Ajax 接口，极大降低了前端开发门槛，并深刻影响了后续前端 API 的设计方式。

然而，在现代浏览器环境（Chrome、Firefox、Safari、Edge）下，Web 平台本身已经发生了显著变化：

- 原生 DOM API 已高度统一且功能完善
- `querySelector`、`classList`、`fetch` 等能力已成为标准
- 模块化（ESM）、类型系统（TypeScript）成为主流
- 代码体积、可维护性与可组合性被更加重视
- [你可能不需要 jQuery](https://youmightnotneedjquery.com/)

在这样的背景下，jQuery 的最初的设计目标带来的收益正在逐步减小，甚至带来了负面收益：

- jQuery 本身并不“轻量”
- 为了少量 DOM 辅助能力引入整个库，性价比不高
- Tree-shaking 基本无效（jQuery 是整体设计）

这与当下“按需引入、最小体积”的趋势并不契合。

## 模块化与独立性优先

domtify 的一个核心原则是：

> **每一个方法都应该是独立的、可拆卸的。**

每个功能模块都尽量保持“单一职责”，彼此之间不强依赖。
这意味着你可以自由地添加、删除或替换某些能力，而不会破坏整个库的结构。

这可能会带来一定的代码冗余，但换来的是：

- 更高的可定制性
- 更清晰的实现逻辑
- 更容易维护和演进的代码结构

## 原生优先，语义清晰

在实现层面，domtify **尽可能使用原生 JavaScript API**，不做多余的抽象。
每一个方法都应当：

- 行为直观
- 命名清晰
- 易于阅读和理解

**代码可读性始终优先于技巧性。**

## 面向现代浏览器，而不是历史包袱

domtify 明确面向现代浏览器环境（Chrome、Firefox、Safari、Edge）。
我们不会为了兼容过时的浏览器而牺牲代码质量或 API 设计。

推动 Web 技术向前发展，比维持旧环境的兼容性更重要。

## 不是黑盒，而是工具箱

许多 JavaScript 库更像是“黑盒”：
你只能使用它提供的 API，却很难真正理解或修改内部实现。

domtify 则刻意避免这种设计，在内部实现直接使用平台能力，在必要处做最小封装。
domtify 不试图限制你，而是给你一个清晰、可塑的起点。

## 尊重历史，面向当下

选择不使用 jQuery，并不意味着否定它的价值。
在维护遗留项目、依赖成熟插件生态或快速原型开发中，jQuery 依然是合理且务实的选择。

domtify 所做的，只是基于现代 Web 平台现状，选择了一条更贴近原生、更易演进的道路。
